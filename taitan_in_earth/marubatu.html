<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>マルバツゲーム - panelState 管理版</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: #f8f8f8;
        font-family: sans-serif;
      }

      .header-container {
        position: absolute;
        top: 0;
        width: 100%;
        padding: 10px 20px;
        box-sizing: border-box;
      }
      .message {
        margin-left: auto;
        font-size: 1.1em;
        color: #333;
      }

      /* ラッパー（grid と panel を重ねる） */
      #board-wrapper {
        position: relative;
        width: 400px;
        height: 400px;
        margin-top: 120px;
      }

      .grid-container {
        display: grid;
        grid-template-columns: repeat(5, 80px);
        grid-template-rows: repeat(5, 80px);
        border: 2px solid black;
        width: 400px;
        height: 400px;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      .grid-cell {
        width: 80px;
        height: 80px;
        box-sizing: border-box;
        border: 1px solid black;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2.5em;
        font-weight: bold;
        user-select: none;
        background: white;
        cursor: pointer;
      }

      /* パネル（grid の上に重ねる） */
      .panel-container {
        display: grid;
        grid-template-columns: repeat(5, 80px);
        grid-template-rows: repeat(5, 80px);
        width: 400px;
        height: 400px;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2;
        pointer-events: none; /* デフォルト透過、個々の .square が pointer-events:auto を持つ */
      }

      .panel-cell {
        width: 80px;
        height: 80px;
        box-sizing: border-box;
        position: relative;
      }

      /* cover（緑四角）: マス全体を覆う */
      .square {
        position: absolute;
        top: 0;
        left: 0;
        width: 105%;
        height: 105%;
        border: 5px solid #fff9f9;
        box-sizing: border-box;
        background: #fff9f9;
        pointer-events: auto; /* これでクリックを受け取る */
        cursor: pointer;
        z-index: 3;
      }

      /* ひび割れSVG */
      .crack {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
        z-index: 4;
      }
      .crack.show {
        opacity: 1;
      }

      .circle {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 4px solid red;
      }
      .cross {
        width: 56px;
        height: 56px;
        position: relative;
      }
      .cross::before,
      .cross::after {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        width: 4px;
        height: 100%;
        background: blue;
        transform-origin: center;
      }
      .cross::before {
        transform: translateX(-50%) rotate(45deg);
      }
      .cross::after {
        transform: translateX(-50%) rotate(-45deg);
      }

      .result-message {
        font-size: 1.4em;
        margin: 12px 0;
        color: #444;
      }
      .retry-btn {
        margin-bottom: 8px;
        padding: 8px 12px;
        border-radius: 6px;
        border: none;
        background: #4caf50;
        color: white;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="header-container">
      <div class="message">まだあなたのことは信用できません</div>
    </div>

    <div id="board-wrapper">
      <div class="grid-container" id="grid"></div>
      <div class="panel-container" id="panel"></div>
    </div>

    <p class="result-message" id="result">ゲーム中...</p>
    <p id="x_cnt">のこり:3</p>
    <button class="retry-btn" onclick="retry()">リトライ</button>

    <script>
      // --- ゲームデータ（3x3 ボード。レンダリング時は 5x5 の中央に配置） ---
      let board = [
        ["", "", ""],
        ["", "X", ""],
        ["", "", ""],
      ];

      // ミニマックス等（既存ロジック保持）
      let x_ = 0,
        y_ = 0,
        m_ = 0;
      let b_ = board.map((r) => [...r]);
      function AI(t) {
        let winner = checkWinner(b_);
        if (winner != null) return winner === "X" ? 1 : -1;
        let x_r = 0,
          y_r = 0,
          m_r = -Infinity;
        if (t === 1) m_r = Infinity;
        for (let i = 0; i <= 2; i++) {
          for (let j = 0; j <= 2; j++) {
            if (b_[i][j] !== "") continue;
            b_[i][j] = t === 0 ? "X" : "O";
            let ret = AI(1 - t);
            if (t === 0) {
              if (ret > m_r) {
                x_r = i;
                y_r = j;
                m_r = ret;
              }
            } else {
              if (ret < m_r) {
                x_r = i;
                y_r = j;
                m_r = ret;
              }
            }
            b_[i][j] = "";
          }
        }
        x_ = x_r;
        y_ = y_r;
        m_ = m_r;
        return m_;
      }

      // --- panelState（二次元配列で管理） ---
      // values: "intact", "cracked", "removed", null (null は最初からパネル無し)
      const panelState = [];
      for (let r = 0; r < 5; r++) {
        panelState[r] = [];
        for (let c = 0; c < 5; c++) {
          // 中央の 3x3 (rows 1..3, cols 1..3) は最初からパネル無し
          if (r >= 1 && r <= 3 && c >= 1 && c <= 3) {
            panelState[r][c] = null;
          } else {
            panelState[r][c] = "intact";
          }
        }
      }

      // ----- ヘルパー関数 -----
      // 指定 panel マスが覆われているかを返す
      function isPanelCovered(row, col) {
        const s = panelState?.[row]?.[col];
        return s === "intact" || s === "cracked";
      }

      // クリック時に呼ばれる関数（要件）：
      // 「クリックされたときにそのマスが覆われているかどうかを返す」
      function panelCellClicked(row, col) {
        const covered = isPanelCovered(row, col);
        console.log(`panelCellClicked(${row},${col}) => ${covered}`);
        return covered;
      }

      // 盤面セルが有効（覆われていない）なときに呼ぶプレースホルダ
      function onCellActivated(boardX, boardY) {
        console.log("onCellActivated called for", boardX, boardY);
        // あとで実装してください
      }

      let now_x_placed = 0,
        zanki = 3;

      // grid 側のクリック処理
      function handleGridCellClick(panelRow, panelCol) {
        if (zanki === 0) return;
        // panelRow, panelCol are 0..4
        // only respond when the cell maps to board (center 3x3)
        if (
          !(panelRow >= 1 && panelRow <= 3 && panelCol >= 1 && panelCol <= 3)
        ) {
          if (isPanelCovered(panelRow, panelCol)) {
            return;
          } else {
            if (zanki === 1 && now_x_placed === 3) {
              //改めて盤面を5×5で見て、ビンゴしてたらOK
            } else {
              return;
            }
          }
        }
        const boardX = panelRow - 1;
        const boardY = panelCol - 1;

        // 覆われているなら処理しない
        if (isPanelCovered(panelRow, panelCol)) {
          console.log("このマスはパネルで覆われています。");
          return;
        }

        // ここで将来の処理を呼ぶ
        onCellActivated(boardX, boardY);

        // 既存ゲームの動作（O を置いて AI を動かす） — 必要なら残す
        if (board[boardX][boardY] != "" || checkWinner(board)) return;
        board[boardX][boardY] = "O";
        b_ = board.map((r) => [...r]);
        AI(0);
        board[x_][y_] = "X";
        now_x_placed++;
        zanki--;
        document.getElementById("x_cnt").textContent = `のこり:${zanki}`;
        renderGrid(); // グリッドだけ再描画（panel は再生成しない）
      }

      // ひび割れ SVG を生成（panelCell に append する）
      function createCrackSVG() {
        const svgns = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgns, "svg");
        svg.setAttribute("viewBox", "0 0 80 80");
        svg.classList.add("crack");
        const paths = [
          "M8 40 L28 28 L40 40 L52 18 L68 36",
          "M40 8 L40 40 L44 60",
          "M12 52 L24 42",
          "M60 52 L48 42",
        ];
        for (const d of paths) {
          const p = document.createElementNS(svgns, "path");
          p.setAttribute("d", d);
          p.setAttribute("stroke", "rgba(20,20,20,0.95)");
          p.setAttribute("stroke-width", "2");
          p.setAttribute("fill", "none");
          svg.appendChild(p);
        }
        return svg;
      }

      // panel UI を初期化（一度だけ呼ぶ）
      function initPanel() {
        const panel = document.getElementById("panel");
        panel.innerHTML = ""; // 初回は空なのでOK

        for (let r = 0; r < 5; r++) {
          for (let c = 0; c < 5; c++) {
            const cell = document.createElement("div");
            cell.className = "panel-cell";
            cell.dataset.r = r;
            cell.dataset.c = c;

            // ここで panelState に従い .square(cover) を作るかどうか決める
            const s = panelState[r][c];
            if (s === "intact" || s === "cracked") {
              const sq = document.createElement("div");
              sq.className = "square";
              sq.dataset.state = s; // "intact" または "cracked"
              // ひび要素
              const crack = createCrackSVG();
              if (s === "cracked") crack.classList.add("show");
              cell.appendChild(crack);
              cell.appendChild(sq);

              // クリックハンドラを登録（state と panelState を更新）
              sq.addEventListener("click", (e) => {
                e.stopPropagation();
                const row = Number(cell.dataset.r);
                const col = Number(cell.dataset.c);
                // 要求どおり、クリックされたときにそのマスが覆われているかを返す
                const coveredNow = panelCellClicked(row, col);

                // 状態遷移： intact -> cracked -> removed
                const cur = panelState[row][col];
                if (cur === "intact") {
                  panelState[row][col] = "cracked";
                  sq.dataset.state = "cracked";
                  crack.classList.add("show");
                } else if (cur === "cracked") {
                  panelState[row][col] = "removed";
                  // remove DOM nodes
                  sq.remove();
                  crack.remove();
                }
              });
            }
            // pointer-events は panel 全体では none なので個々の .square のみ受け取る
            panel.appendChild(cell);
          }
        }
      }

      // panel の特定マスの UI を更新（状態の変更があるときに呼ぶ）
      function updatePanelCellUI(row, col) {
        const panel = document.getElementById("panel");
        if (!panel) return;
        const idx = row * 5 + col;
        const cell = panel.children[idx];
        if (!cell) return;
        // まず既存要素をクリア（安全のため）
        cell.innerHTML = "";
        const s = panelState[row][col];
        if (s === "intact" || s === "cracked") {
          const sq = document.createElement("div");
          sq.className = "square";
          sq.dataset.state = s;
          const crack = createCrackSVG();
          if (s === "cracked") crack.classList.add("show");
          cell.appendChild(crack);
          cell.appendChild(sq);
          sq.addEventListener("click", (e) => {
            e.stopPropagation();
            if (panelState[row][col] === "intact") {
              panelState[row][col] = "cracked";
              updatePanelCellUI(row, col);
            } else if (panelState[row][col] === "cracked") {
              panelState[row][col] = "removed";
              updatePanelCellUI(row, col);
            }
          });
        }
        // null または removed -> 空にする（覆われていない）
      }

      // ------- grid（盤面）を描画（panel は再描画しない） -------
      function renderGrid() {
        const grid = document.getElementById("grid");
        grid.innerHTML = "";

        for (let r = 0; r < 5; r++) {
          for (let c = 0; c < 5; c++) {
            const cell = document.createElement("div");
            cell.className = "grid-cell";

            // 中央 3x3 のみ board の値を描画
            if (r >= 1 && r <= 3 && c >= 1 && c <= 3) {
              const br = r - 1;
              const bc = c - 1;
              const val = board[br][bc];
              if (val === "O") {
                const circle = document.createElement("div");
                circle.className = "circle";
                cell.appendChild(circle);
              } else if (val === "X") {
                const cross = document.createElement("div");
                cross.className = "cross";
                cell.appendChild(cross);
              }
              // grid 側のクリック：内部では panelState をチェック
              cell.addEventListener("click", () => handleGridCellClick(r, c));
            } else {
              // パディングセル。クリックしても何もしない
              cell.style.background = "#f7f7f7";
              cell.style.cursor = "default";
            }

            grid.appendChild(cell);
          }
        }

        // 勝敗表示
        const winner = checkWinner(board);
        const resultEl = document.getElementById("result");
        if (winner) resultEl.textContent = winner + " の勝ち！";
        else resultEl.textContent = "ゲーム中...";
      }

      // 勝敗判定（既存）
      function checkWinner(board_) {
        const lines = [
          [board_[0][0], board_[0][1], board_[0][2]],
          [board_[1][0], board_[1][1], board_[1][2]],
          [board_[2][0], board_[2][1], board_[2][2]],
          [board_[0][0], board_[1][0], board_[2][0]],
          [board_[0][1], board_[1][1], board_[2][1]],
          [board_[0][2], board_[1][2], board_[2][2]],
          [board_[0][0], board_[1][1], board_[2][2]],
          [board_[0][2], board_[1][1], board_[2][0]],
        ];
        for (const line of lines) {
          if (line[0] && line[0] === line[1] && line[0] === line[2])
            return line[0];
        }
        return null;
      }

      // リトライ: board と panelState を初期化して UI を再構築
      function resetPanelStateToDefault() {
        for (let r = 0; r < 5; r++) {
          for (let c = 0; c < 5; c++) {
            if (r >= 1 && r <= 3 && c >= 1 && c <= 3) panelState[r][c] = null;
            else panelState[r][c] = "intact";
          }
        }
      }
      function retry() {
        zanki = 3;
        document.getElementById("x_cnt").textContent = `のこり:${zanki}`;
        now_x_placed = 0;

        board = [
          ["", "", ""],
          ["", "X", ""],
          ["", "", ""],
        ];
        resetPanelStateToDefault();
        // panel は初期化し直す（安全のため再生成）
        initPanel();
        renderGrid();
      }

      // 初期化
      initPanel(); // panel を一度だけ作る
      renderGrid(); // grid を描画

      // （必要であれば外部から読み出せるように expose）
      window.isPanelCovered = isPanelCovered;
      window.panelCellClicked = panelCellClicked;
      window.panelState = panelState;
      window.updatePanelCellUI = updatePanelCellUI;
    </script>
  </body>
</html>
